# 浏览器渲染原理

## 一、浏览器渲染过程

 * 浏览器将接收到的HTML文档解析生成DOM树

 * 浏览器解析CSS并生成CSSOM树

 * 浏览器将DOM树和CSSOM树合并为Render渲染树（我们常说的脱离文档流就是脱离Render树）

 * 根据Render树来计算每个节点的大小和位置

 * 将每个节点绘制到屏幕上，这一步称为painting


## 二、阻塞渲染

* CSS不会阻塞浏览器解析文档（当浏览器解析到link标签时若css资源未下载完成不会停顿，继续解析文档），但会阻塞浏览器渲染文档，因为浏览器在CSSOM未生成前不会进行渲染

* 由于JS可以修改DOM和CSSOM的结构，因此CSS的解析与JS的执行是互斥的。当浏览器解析到script标签时，在此之前若在script标签之前的css资源未加载完成则会等待加载完成后执行js文件（因为浏览器并不知道这个js文件是否需要修改DOM和样式）。同时，script标签也会阻塞浏览器解析文档，浏览器遇到script标签时必须停下来等js执行完后再接着解析。浏览器的预加载扫描器会提前扫描和加载link、script、img等资源，而不是等到解析到这些标签才开始加载。

  **script标签的defer和async属性**
  * defer：浏览器解析到当前位置时，会并行下载js文件并继续解析文档，js文件加载完成后会在DOMContentLoaded事件前执行。
  * async：浏览器解析到当前位置时，会异步下载js文件并继续解析文档，js文件加载完成后会立即执行（可能在DOMContentLoaded事件前也可能在之后执行，但一定在load事件前执行）。

  **因此实际开发中应遵循以下原则**
  
  * JS应当尽量减少对DOM和CSSOM的修改
  * CSS资源的引入应当优先于JS

## 三、重绘和重排

> 什么是重绘和重排？
>
> 重绘（repaint）：当改变某个元素的颜色等不影响布局的属性时，屏幕的一部分要进行repaint，但元素的几何尺寸和位置没有发生改变。
>
> 重排（reflow）：当浏览器发现某个元素的尺寸和位置发生了变化从而影响了布局，这时就应该倒回去重新渲染，reflow会从根节点开始向下一次计算所有节点的几何尺寸和位置，以确定是渲染树的一部分发生了变化还是整个渲染树。

​	重绘和重排对于浏览器来说是一笔昂贵的开销，这会使得浏览器的线程卡顿，因此我们应当尽量减少重绘和重排的次数。

**如何减少重绘和重排的次数**

